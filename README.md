# 22-23秋 国科大操作系统高级教程课程笔记

## 基础知识

- 栈由高地址向低地址生长

## 从开机到执行main的过程

### 操作系统授权体系的设计指导思想

#### 公理化操作系统

##### 术语

- **亚里士多德的直言三段论**

  三段论是演绎推理中一种简单推理判断, 包含大前提, 小前提, 结论三部分. 全集为真则子集为真.

- **证明**

  由公理经由可靠的论证 (如三段论) 推出命题.

- **公理, 公设**

  公理是不证自明 (目前无法举出反例) 的一个命题, 是推导其他命题的起点. 在传统逻辑中, 公设是在一特定数学理论中的定义性的性质. 公设并不是不证自明的命题, 而是在构建一个数学理论的过程中被用来推导的一个形式逻辑表达式. 而在近代, *公理和公设不再有区别*. 在一个公理化体系中所有其他命题都必须由公理证明.

- **科学**

  科学的范畴是可观察范围内, 科学的标准是**可证伪** (因为无法直接获得真理, 科学无法证实). 而数学不可观察, 可证实 (基于公理),  因此不算科学.

#### 操作系统的内核

##### 操作系统为什么一定要有内核

现代操作系统是**多用户, 实时, 多任务**的, 访问应当经过授权.

> **授权**: 未经许可不得访问其他用户的资源.

- **用户**: shell绑定的是用户, 包括文件, 进程, 外设等很多东西
- **资源**: 包括主机上的 (数据, 代码, 进程), 外设 (显示器, 键盘等)
- 授权是面向访问的, 一项访问一项授权
- 授权有三要素: 用户, 操作,  数据 (一次访问所需信息至少包括这三项, 也可以有更多信息, 比如时间), 单独任意一项都无法完全限定一次访问的权限, 如授权A用户读取X文件的权限, 授权B用户读写X文件的权限.

操作系统应当尽可能赋予用户操作的自由, 因此用户代码会具有不确定性 (不确定会对什么数据/代码做什么), 为了保证所有访问都是经过授权的, 要求:

- 未经许可用户不得访问外设中自己的资源, 因为同一外设端口下可能有其他用户的资源 (比如同一硬盘中有多个用户的数据)
  - 💡现有体系结构中访问外设有两种方式:
    1. IO指令: 较老, 新处理器中基本弃用这种方式. 禁止非特权用户使用, 剥夺普通用户IO能力
    2. MMIO (内存映射): 仅将合法资源映射到内存中用户能访问到的部分
- 同一用户两进程间不共享资源 (历史上先有程序概念后有用户概念, 为保兼容性, 权限管理以进程为单位而不是以用户为单位)

然而如此一来违背了"用户访问自己的资源无需授权"的设想, 因此引入一组由授权体系设计者实现的确定的程序, 即**内核**来代替用户完成访问. 此处的确定指访问的过程和对象都确定.

##### 为什么要有特权级

- **特权级建立在线性地址空间中的代码段上**

  - **虚拟地址空间**: CPU可访问地址空间, intel称**线性地址空间**
  - 访问控制技术都是施加在线性地址层面的, 因此段的地址都是线性空间地址

- 一共有四种情况: (在只有两种特权级的系统中0特权级/3特权级也称内核态/用户态)

  | 发起者    | 操作 | 对象      |
  | --------- | ---- | --------- |
  | 0特权指令 | 访问 | 0特权数据 |
  | 0特权指令 | 跳转 | 0特权指令 |
  | 3特权指令 | 访问 | 3特权数据 |
  | 3特权指令 | 跳转 | 3特权指令 |

  0特权指令*直接*跳转到3特权指令不被允许, 否则若特权级不变, 内核与应用程序就混淆起来了.

##### 内核为什么一定要有结构

> **接续访问机制**: 用户发起 -> 内核接续 (IO操作) -> 交付用户

- **内核是应用程序访问的延续**, 所有访问都由应用程序发起
  - 一次访问至少需要至少包含用户, 操作, 数据三项在内的各种信息
  - 访问种类过多, 因此应当预先设定好一组服务

- **intel的门机制**: 为确保由用户接续到内核过程中状态翻转的确定性, 要求指令确定, 跳转地址确定.

  若跳转地址不确定, 可以直接跳转到内核函数代码段进行特权级操作. 返回的跳转地址也确定 (跳转指令的下一条)

接续访问的重要保障是能在内核态与用户态间借由一些硬件机制建起"一道墙" (进程管理信息数据结构), 确保用户态与内核态的隔离, 但内核可以借助这些机制"建墙"理论上用户就可以利用这些机制"拆墙". 这里利用**时间的不可逆实现空间的不可逆**. 由"拆墙需要为内核态, 想成为内核态需要先拆墙"互为必要条件锁死, 最先创建的用户会具有完全权限, 0特权级.

### 内核代码的加载

从按下开机键到执行32位main函数分下面标题的三步准备工作.

#### 启动BIOS, 准备实模式下的中断向量表和中断服务程序

CPU的逻辑电路被设计为只能运行内存中的程序, 因此加电瞬间intel80x86系列cpu进入16位实模式, `CS:IP`被硬件上强制置为`0xFFFF0` (CS<<4+IP), 即BIOS程序此时在内存中的入口地址.

💡实模式有20位存储器地址空间, 即1MB内存可被寻址 (按字节)

#### 从启动盘加载操作系统程序到内存并为保护模式做准备

这步的==?==是利用第一步准备的中断服务程序实现的.

#### 为执行32位的main函数做准备

1扇区是bootsect.S, 2-5扇区为setup.S

## 设备环境初始化

GDT不能称为段, 因为没有描述符用于描述GDT. ==但GDT本身确实在GDT的第二个?==

- 保护模式是什么

进程不会直接读写硬盘, 而是读写的内存中的缓冲区, 而缓冲区与硬盘间有同步机制. 进程并不知道数据何时被写到硬盘.

每个进程有个用户栈, 也有个内核栈.

## 进程创建进程1

## 进程1的执行

## 等待队列