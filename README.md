# 22-23秋 国科大操作系统高级教程课程笔记

## 基础知识

- ![](README/image-20221022175352625.png)
- 栈由高地址向低地址生长
- **CS** (Code Segment Register): 代码段寄存器, 在CPU中, 记录当前执行代码段在内存中起始位置
- **IP** (Instruction Pointer): 指令指针寄存器, 记录将要执行的指令在代码段中偏移地址. `CS<<4+IP`即下一条执行的指令的内存地址. 实模式下IP为16位, 保护模式下为EIP, 32位线性地址.
- **GDTR**: GDT基地址寄存器. GDT可以存放在内存任何位置, 操作系统对GDT初始化后用`LGDT`指令将GDT基地址加载到GDTR, 通过GDTR维护其基地址.
- **IDTR**: IDT基地址寄存器. 同理IDT也可以在内存任何位置.
- **GDT** (Global Descriptor Table): 全局描述符表, 系统中唯一存放段寄存器内容 (段描述符) 的数组
  ![](README/image-20221022172150224.png)
- **IDT** (Interrupt Descriptor Table): 中断描述符表, 保存保护模式下所有中断服务程序的入口地址, 类似实模式下中断向量表.
- SP
- 常用数值:
	- 1KB: 0X400
	- 4KB: 0X1000

## 从开机到执行main的过程

### 操作系统授权体系的设计指导思想

#### 公理化操作系统

##### 术语

- **亚里士多德的直言三段论**

  三段论是演绎推理中一种简单推理判断, 包含大前提, 小前提, 结论三部分. 全集为真则子集为真.

- **证明**

  由公理经由可靠的论证 (如三段论) 推出命题.

- **公理, 公设**

  公理是不证自明 (目前无法举出反例) 的一个命题, 是推导其他命题的起点. 在传统逻辑中, 公设是在一特定数学理论中的定义性的性质. 公设并不是不证自明的命题, 而是在构建一个数学理论的过程中被用来推导的一个形式逻辑表达式. 而在近代, *公理和公设不再有区别*. 在一个公理化体系中所有其他命题都必须由公理证明.

- **科学**

  科学的范畴是可观察范围内, 科学的标准是**可证伪** (因为无法直接获得真理, 科学无法证实). 而数学不可观察, 可证实 (基于公理),  因此不算在科学范畴内.

#### 操作系统的内核

##### 操作系统为什么一定要有内核

现代操作系统是**多用户, 实时, 多任务**的, 访问应当经过授权.

> **授权**: 未经许可不得访问其他用户的资源.

- **用户**: shell绑定的是用户, 包括文件, 进程, 外设等很多东西
- **资源**: 包括主机上的 (数据, 代码, 进程), 外设 (显示器, 键盘等)
- 授权是面向访问的, 一项访问一项授权
- 授权有三要素: 用户, 操作,  数据 (一次访问所需信息至少包括这三项, 也可以有更多信息, 比如时间), 单独任意一项都无法完全限定一次访问的权限, 如授权A用户读取X文件的权限, 授权B用户读写X文件的权限.

操作系统应当尽可能赋予用户操作的自由, 因此用户代码会具有不确定性 (不确定会对什么数据/代码做什么), 为了保证所有访问都是经过授权的, 要求:

- 未经许可用户不得访问外设中自己的资源, 因为同一外设端口下可能有其他用户的资源 (比如同一硬盘中有多个用户的数据)
  - 💡现有体系结构中访问外设有两种方式:
    1. IO指令: 较老, 新处理器中基本弃用这种方式. 禁止非特权用户使用, 剥夺普通用户IO能力
    2. MMIO (内存映射): 仅将合法资源映射到内存中用户能访问到的部分
- 同一用户两进程间不共享资源 (历史上先有程序概念后有用户概念, 为保兼容性, 权限管理以进程为单位而不是以用户为单位)

然而如此一来违背了"用户访问自己的资源无需授权"的设想, 因此引入一组由授权体系设计者实现的确定的程序, 即**内核**来代替用户完成访问. 此处的确定指访问的过程和对象都确定.

##### 为什么要有特权级

- **特权级建立在线性地址空间中的代码段上**
  - ==特权本质上是对访问的控制==
  - **虚拟地址空间**: CPU可访问地址空间, intel称**线性地址空间**
  - 访问控制技术都是施加在线性地址层面的, 因此段的地址都是线性空间地址

- 一共有四种情况: (在只有两种特权级的系统中0特权级/3特权级也称内核态/用户态)

  | 发起者    | 操作 | 对象      |
  | --------- | ---- | --------- |
  | 0特权指令 | 访问 | 0特权数据 |
  | 0特权指令 | 跳转 | 0特权指令 |
  | 3特权指令 | 访问 | 3特权数据 |
  | 3特权指令 | 跳转 | 3特权指令 |

  0特权指令*直接*跳转到3特权指令不被允许, 否则若特权级不变, 内核与应用程序就混淆起来了.

##### 内核为什么一定要有结构

> **接续访问机制**: 用户发起 -> 内核接续 (IO操作) -> 交付用户

- **内核是应用程序访问的延续**, 所有访问都由应用程序发起
  - 一次访问至少需要至少包含用户, 操作, 数据三项在内的各种信息
  - 访问种类过多, 因此应当预先设定好一组服务

- **intel的门机制**: 为确保由用户接续到内核过程中状态翻转的确定性, 要求指令确定, 跳转地址确定.

  若跳转地址不确定, 可以直接跳转到内核函数代码段进行特权级操作. 返回的跳转地址也确定 (跳转指令的下一条)

接续访问的重要保障是能在内核态与用户态间借由一些硬件机制建起"一道墙" (进程管理信息数据结构), 确保用户态与内核态的隔离, 但内核可以借助这些机制"建墙"理论上用户就可以利用这些机制"拆墙". 这里利用**时间的不可逆实现空间的不可逆**. 由"拆墙需要为内核态, 想成为内核态需要先拆墙"互为必要条件锁死, 最先创建的用户会具有完全权限, 0特权级.

### 内核代码的加载

从按下开机键到执行32位main函数分下面标题的三步准备工作. 准备工作完成后内存分布如图所示.
![|400](README/image-20221016170443887.png)

#### 启动BIOS, 准备实模式下的中断向量表和中断服务程序

CPU的逻辑电路被设计为只能运行内存中的程序, 因此加电瞬间intel80x86系列CPU进入16位实模式, `CS:IP`被**硬件**强制置为`0xFFFF0` (CS<<4+IP), 即BIOS程序此时在内存中的入口地址, 从而开始执行BIOS程序.

💡实模式有20位存储器地址空间, 即1MB内存可被寻址 (按字节), 按**物理地址**寻址.

站在操作系统角度BIOS最重要的功能就是==将操作系统最开始执行的程序 (通常是引导程序) 加载到内存并跳转执行, 从而进入操作系统自己的启动流程==. BIOS程序构建中断向量表, 加载中断服务程序, 然后硬件触发BIOS提供的中断`int 0x19`加载**bootsect**引导程序到内存中[约定地址](https://www.ruanyifeng.com/blog/2015/09/0x7c00.html)`0X07C00` (BOOTSEG), 然后开始执行位于`0X07C00`的bootsect (对应*boot/bootsect.s*).

💡`int 0x19`的唯一作用就是将软盘第一扇区512B的内容复制到内存`0X07C00`处.

💡BIOS创建的中断向量表 (`0X00000`~`0X003FF`) 及加载的中断服务程序 (`0x0E05B`~`0X0FFFE`) 在**setup**程序将120KB的system模块 (**head**程序及以main函数开始的内核程序) 复制至内存起始位置时被覆盖.

#### 从启动盘加载操作系统程序到内存并为保护模式做准备

![|800](README/image-20221017025958081.jpeg)

**bootsect**程序最主要作用是将**setup**程序和system模块加载到内存中. 上图中代码在内存中移动的一些解释:
- **bootsect**程序通过触发BIOS提供的中断`int 0x13`将指定扇区内容加载到内存指定位置 (通过设置寄存器的值来传参)
- **bootsect**程序一开始先将自己移动到`0X90000`是因为当时system模块长度不会超过`0X80000`字节 (在Linux0.11中只有120KB), 因此从`0X07C00`移动到`0X90000`能保证**bootsect**程序不会被自己加载的system模块覆盖.
- system模块一开始被**bootsect**程序加载到`0X10000`而不是内存起始位置是因为只有使用BIOS提供的中断`int 0x13`才能从软盘读取system模块所在扇区, 使用指令无法操作外部设备, 而直接将system模块加载到内存起始位置会导致BIOS的中断向量表和中断服务程序被覆盖, 无法再加载system模块. 因此只能先将system模块加载至内存中别的地方, 再在关掉中断后用指令将system模块挪到内存起始位置.

**setup**程序在一开始利用BIOS提供的中断提取到了一些机器信息存放至内存`0X90000`~`0X901FC`, 基本覆盖了**bootsect**程序. 这之后就不再用到BIOS提供的中断服务程序, 甚至关闭中断, 覆盖掉了BIOS的中断向量表和中断服务程序.

#### 为执行32位的main函数做准备

因为将system模块挪至内存起始位置会覆盖掉BIOS的中断向量表和中断服务程序, 为了避免问题**setup**程序先用`cli`将CPU的EFLAGS中中断允许标志 (IF) 置为0==关闭了中断==, 然后才将system模块挪至内存起始位置.

GDT

## 设备环境初始化

GDT不能称为段, 因为没有描述符用于描述GDT. ==但GDT本身确实在GDT的第二个?==

- 保护模式是什么

进程不会直接读写硬盘, 而是读写的内存中的缓冲区, 而缓冲区与硬盘间有同步机制. 进程并不知道数据何时被写到硬盘.

每个进程有个用户栈, 也有个内核栈.

## 进程创建进程1

## 进程1的执行

## 等待队列